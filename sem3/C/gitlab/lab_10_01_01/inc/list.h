#ifndef LIST_H__
#define LIST_H__

#include <stdlib.h>
#include <stdio.h>

#include "errs.h"
#include "node_list.h"

/// @brief Добавляет новый узел в конец списка
/// @param [in] head - указатель на голову списка
/// @param [in] node - указатель на новый узел
/// @return голова списка с ноым узлом
node_t *add_tail_list(node_t *head, node_t *node);

/// @brief Добавляет новый узел в конец списка по указателю на конец списка
/// @param [in out] head - указатель на указатель голову списка
/// @param [in out] tail - указатель на указатель на последний элемент списка
/// @param [in] new_node - указатель на новый узел
void fast_add_tail_list(node_t **head, node_t **tail, node_t *new_node);

/// @brief Выводит список
/// @param [in out] f - файловая переменная 
/// @param [in] head - указатель на голову списка
/// @param [in] print_data - функция печати данных
void print_list(FILE *f, node_t *head, void (*print_data)(FILE *, void *));

/// @brief Освобождает память из под списка
/// @param [in] head - указатель на голову списка
void free_list(node_t *head);

/// @brief Освобождает память из под данных списка
/// @param [in] head - указатель на голову списка
/// @param [in] free_data - функция освобождения данных
void free_data_list(node_t *head, void (*free_data)(void *));

// /// @brief Считает количество элементов в списке
// /// @param [in] head - указатель на голову списка
// /// @return кол-во элементов в списке
// size_t count_list(node_t *head);

/// @brief Получает список и делит его на две половины.
/// Если в списке нечетное число элементоа, "серединные" элемент
/// должен попасть в первую половину
/// @param [in out] head - указатель на голову упорядоченного списка, 
/// а после указатель на первую половину списка 
/// @param [out] back - указатель на вторую половину списка 
void front_back_split(node_t *head, node_t **back);

/// @brief Получает 2 упорядоченных списка и обьединяет их в один
/// Списки становятся пустыми, элементы из них
/// "переходят" в упорядоченный
/// @param [in] head_a - указатель на голову первого упорядоченного списка
/// @param [in] head_b - указатель на голову второго упорядоченного списка
/// @param [in] cmp - функция сравнения элементов 
/// @return Упорядоченный список
node_t *sorted_merge(node_t **head_a, node_t **head_b, cmp_t cmp);

/// @brief Сортирует список методом слияния
/// @param [in out] head - указатель на голову упорядоченного списка
/// @param [in] cmp - функция сравнения элементов 
/// @return "Новая" голова упорядоченного списка
node_t *sort(node_t *head, cmp_t cmp);

/// @brief Создает копию списка
/// Выделяет память под узлы, но данные копируются поверхностно
/// @param [out] dst - указатель на указатель на список копию
/// @param [in] head - указатель на список с которого копируется
/// @return код ошибки
int copy_list(node_t **dst, node_t *head);

/// @brief Ищет первое вхождение элемента с данными data в список
/// Предполагается что такие данные есть в списке, как минимум 1 шт
/// @param [in] head - указатель на список 
/// @param [in] cmp - функция сравнения элементов 
/// @param [in] data - данные по которым иде сравнение
/// @return первое вхождение элемента с данными data в список
node_t *find_first_same_list(node_t *head, cmp_t cmp, void *data);

/// @brief Получает упорядоченный список 
/// и оставляет в нем лишь первые вхождения каждого элемента
/// Совпадение определяется с помощью функции сравнения элементов
/// При удалении элемента спика данные не удаляются
/// @param [in out] head - указатель на голову упорядоченного списка 
/// @param [in] cmp - функция сравнения элементов
void remove_duplicates(node_t **head, cmp_t cmp);











#endif
