# Описание работы программы через цели makefile

## GUI
При создании интерфейся использовался модуль PyQt5. 

("sudo pip3 install PyQt5" - установка модуля)

Внешний вид окна строился в приложении Qt Designer это файлы py/*.ui

После, на основе этих файлов автоматически генерировались скрипты на питоне, в которых находятся классы по созданию интерфейса на языке питон с использованием модуля PyQt5 

(Файлы py/*.ui удялять нельзы так как они понадобятся при потребности изменить интефейс)

## app
Создает все библиотеки: libarr.so pylib_arr.cpython-310-x86_64-linux-gnu.so (для использования модуля расширения)

Запускает программу

## unit, valgrind
Запускаем модульные тесты использующие динамическую компоновку, с валгриндом и без него

## libarr.so
Библиотека функций по заданию 


## libunit.so
Библиотека для модульных тестов



# Работа приложения
Первое окно - окно выбора способа подключения библиотеки на Си к скрипту на питоне

При выборе ctypes всплывает окно выбора пути до библиотеки (можно написать путь вручную или найти библиотеку через программное окно (!в программном окне настройка отображения файлов только *.so)) Если выбрали библиотеку не верно, программа обработает эту ошибку

Далее всплывает окно основной программы

Вводится массив целых чисел и k (параметр на который сдвигать массив)

И по нажатию на соответствующую кнопку реализуются заданные по заданию действия

Можно выбрать способы выделения памяти
- экономичный - память под результирующий массив выделяется ровно столько сколько надо, за счет двойного вызова исходной функции
- с запасом - вычисляется наибольший возможный размер выходного массива и выделяется память большая чем надо

